# Задача: Верстка Шаблонов и Генерация PDF

**Цель:** Превратить JSON данные из стейта в красивый, профессиональный документ, который идеально печатается на листе А4, сохраняя кликабельность ссылок и читаемость для роботов (ATS).

**Основные вызовы:**
1.  **Адаптивность контента:** Резюме не должно выглядеть сломанным, если текста мало или слишком много.
2.  **Чистота данных:** Пустые поля не должны оставлять дыр в верстке.
3.  **Физика печати:** Контроль разрывов страниц — текст не должен резаться посередине строки.

---

## Часть 1: Разработка Логики Шаблонов (Phase 4)

### Шаг 1: Утилиты форматирования (Helpers)
Перед версткой нужно подготовить функции для обработки сырых данных.

1.  **Форматер Дат (`dateUtils.ts`):**
    - Написать функцию, которая принимает строку `2023-01-15` и возвращает `Jan 2023` или `Январь 2023` (в зависимости от локали).
    - Реализовать логику "По настоящее время": если `endDate` отсутствует или помечен флагом, выводить `Present` / `Наст. время`.
2.  **Очистка ссылок (`urlUtils.ts`):**
    - Функция, которая убирает `https://` и `www.` из текста ссылки для красоты (например, отображать `linkedin.com/in/me`, но ссылка ведет на полный URL).

### Шаг 2: Компонент "Умная Секция"
Чтобы не дублировать код проверки на пустоту (`if (!data) return null`), создай обертки.

1.  **Компонент `<Section />`:**
    - Принимает `title` и массив данных.
    - Логика: Если массив пуст (`length === 0`), компонент возвращает `null` (ничего не рендерит).
2.  **Компонент `<ContactItem />`:**
    - Принимает `value`, `icon`, `link`.
    - Логика: Если `value` пустая строка — не рендерит иконку и отступы.

### Шаг 3: Верстка Шаблона (на примере Classic)
Сборка компонента `TemplateClassic.tsx`.

1.  **Grid/Flex сетка:**
    - Использовать CSS Grid для жесткой структуры (хотя Classic чаще одна колонка, Modern будет на Grid).
2.  **Типографика:**
    - Применить классы Tailwind для шрифтов (например, `font-serif` для Classic).
    - Установить `leading-relaxed` (межстрочный интервал) для основного текста, чтобы он легко читался.
3.  **Отрисовка списков:**
    - Пройтись `.map()` по массивам `experience` и `education`.
    - Важно: Использовать уникальные ID в качестве `key` (не индекс массива!), чтобы React корректно обновлял порядок при сортировке.

### Шаг 4: Обработка переполнения текста
1.  **Word Break:** Добавить CSS класс `break-words` для длинных ссылок или email, чтобы они переносились на новую строку, а не уходили за край листа.
2.  **Line Clamp (Опционально):** Если нужно ограничить описание 5 строками (редко нужно в резюме, но полезно знать).

---

## Часть 2: Настройка Печати и Экспорта (Phase 5)

### Шаг 1: Подготовка CSS для печати (`@media print`)
Браузер добавляет свои колонтитулы и отступы. Нам нужно их убрать.

1.  **Глобальные стили печати (`globals.css`):**
    ```css
    @media print {
      @page {
        margin: 0; /* Убираем дефолтные отступы браузера */
        size: auto; /* Позволяет контенту определять размер */
      }
      body {
        background: white;
      }
      /* Скрываем интерфейс редактора при печати */
      .no-print, header, nav, aside {
        display: none !important;
      }
      /* Убираем тени и границы контейнера А4 */
      .resume-preview-container {
        box-shadow: none;
        margin: 0;
        width: 100%;
        border: none;
      }
    }
    ```

### Шаг 2: Управление Разрывами Страниц (Page Breaks)
Самый критичный момент. Мы не хотим, чтобы заголовок "Опыт работы" остался внизу страницы 1, а список работ уехал на страницу 2.

1.  **Атомарность блоков:**
    - Добавить класс `break-inside-avoid` (Tailwind) или `page-break-inside: avoid` (CSS) для каждого блока:
        - Карточка одной работы (`<ExperienceItem />`).
        - Карточка образования.
        - Блок навыков.
    - *Результат:* Если блок не влезает целиком, он перенесется на следующую страницу полностью.
2.  **Привязка заголовков:**
    - Для заголовков секций (`H2`) добавить `break-after-avoid` (`page-break-after: avoid`).
    - *Результат:* Заголовок "приклеится" к первому элементу списка под ним.

### Шаг 3: Генерация (React-to-Print)
Мы используем библиотеку, чтобы печатать только компонент резюме, а не весь сайт.

1.  **Интеграция:**
    - `npm install react-to-print`
2.  **Создание кнопки:**
    - Создать реф `componentRef`, который указывает на контейнер с резюме.
    - Использовать компонент `<ReactToPrint />`:
      ```jsx
      <ReactToPrint
        trigger={() => <button>Скачать PDF</button>}
        content={() => componentRef.current}
        documentTitle="Ivan_Ivanov_Resume" // Имя файла при сохранении
      />
      ```

### Шаг 4: Проверка качества (QA)
1.  **Тест на ссылки:** Сгенерировать PDF и нажать на email/LinkedIn. Они должны открываться.
2.  **Тест на выделение:** Текст должен выделяться курсором (это значит, что это вектор, а не картинка).
3.  **Тест границ:** Проверить, что контент не прилипает к краю бумаги (соблюдены padding 2.5cm).

---

## Чек-лист готовности (Definition of Done)
- [ ] Данные (даты, ссылки) форматируются корректно.
- [ ] Если я удаляю "Образование", заголовок секции исчезает.
- [ ] При нажатии "Скачать PDF" открывается окно печати.
- [ ] В окне печати нет кнопок редактора, только чистый документ.
- [ ] Текст длинного описания работы не режется пополам между страницами.
- [ ] PDF файл сохраняется с именем кандидата (например, `Resume_John_Doe.pdf`).